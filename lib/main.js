// Generated by CoffeeScript 1.4.0

/*
  k-Nearest Neigbor library
  -------
  subject:  vantage point object -- will consider each attribute present in this object
  objects:  array of objects that should all have at least the attributes of subject
  options:  options hash to specify:
        - k: (default = 1) specifies how many objects to return
        - standardize: (default = false) if true, will apply standardization accross all attributes using stdvs
        - weights: (default = {}) a hash describing the weights of each attribute
*/


(function() {
  var util;

  util = require('./util');

  module.exports = function(subject, objects, options) {
    var attr, distances, i, k, o, object, sortMap, sortedObjects, stdv, weights, _i, _len;
    if (arguments.length < 2) {
      throw new Error('Expecting at least 2 arguments');
    }
    if (!(Array.prototype.slice.call(arguments).every(function(i) {
      return i && typeof i === 'object';
    }))) {
      throw new Error('Expecting object arguments');
    }
    if (!Array.isArray(arguments[1])) {
      throw new Error('Expecting an array as second argument');
    }
    if (!objects.length) {
      return [];
    }
    for (attr in subject) {
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        o = objects[_i];
        if (!(attr in o)) {
          throw new Error("Missing attribute '" + attr + "' in '" + (JSON.stringify(o)) + "'");
        }
      }
    }
    stdv = {};
    if ((options != null ? options.standardize : void 0) != null) {
      stdv = util.allStdvs(subject, objects);
    }
    weights = {};
    if (options != null ? options.weights : void 0) {
      weights = options.weights;
    }
    distances = (function() {
      var _j, _len1, _results;
      _results = [];
      for (i = _j = 0, _len1 = objects.length; _j < _len1; i = ++_j) {
        object = objects[i];
        _results.push({
          index: i,
          dist: util.distance(subject, object, {
            stdv: stdv,
            weights: weights
          })
        });
      }
      return _results;
    })();
    sortMap = distances.sort(function(a, b) {
      return a.dist - b.dist;
    });
    sortedObjects = (function() {
      var _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = sortMap.length; _j < _len1; _j++) {
        i = sortMap[_j];
        _results.push(objects[i.index]);
      }
      return _results;
    })();
    k = (options != null ? options.k : void 0) || 1;
    return sortedObjects.slice(0, k);
  };

}).call(this);
