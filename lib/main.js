// Generated by CoffeeScript 1.4.0

/*
  k-Nearest Neigbor library
  -------
  subject:  vantage point object -- will consider each attribute present in this object
  objects:  array of objects that should all have at least the attributes of subject
  options:  options hash to specify:
        - k: (default = 1) specifies how many objects to return
        - standardize: (default = false) if true, will apply standardization accross all attributes using stdvs
        - weights: (default = {}) a hash describing the weights of each attribute
        - key: (default none) an array key parameter to map over objects, to be used if the subject attributes are nested within key.
              e.g. if subject is {a:0} and objects are [{x: {a: 0}},{x: {a: 2}}], then provide key: ['x']. Use ['x', 'y'] if the object were nested even more.
*/


(function() {
  var util;

  util = require('./util');

  module.exports = function(subject, objects, options) {
    var attr, distances, i, k, o, obj, object, objects_mapped, sortMap, sortedObjects, stdv, weights, _i, _j, _len, _len1, _ref;
    if (arguments.length < 2) {
      throw new Error('Expecting at least 2 arguments');
    }
    if (!(Array.prototype.slice.call(arguments).every(function(i) {
      return i && typeof i === 'object';
    }))) {
      throw new Error('Expecting object arguments');
    }
    if (!Array.isArray(arguments[1])) {
      throw new Error('Expecting an array as second argument');
    }
    objects_mapped = objects;
    if ((options != null ? options.key : void 0) != null) {
      _ref = options.key;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        k = _ref[_i];
        objects_mapped = (function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = objects_mapped.length; _j < _len1; _j++) {
            obj = objects_mapped[_j];
            _results.push(obj[k]);
          }
          return _results;
        })();
      }
    }
    if (!objects_mapped.length) {
      return [];
    }
    for (attr in subject) {
      for (_j = 0, _len1 = objects_mapped.length; _j < _len1; _j++) {
        o = objects_mapped[_j];
        if (!(attr in o)) {
          throw new Error("Missing attribute '" + attr + "' in '" + (JSON.stringify(o)) + "'");
        }
      }
    }
    stdv = {};
    if ((options != null ? options.standardize : void 0) != null) {
      stdv = util.allStdvs(subject, objects_mapped);
    }
    weights = {};
    if (options != null ? options.weights : void 0) {
      weights = options.weights;
    }
    distances = (function() {
      var _k, _len2, _results;
      _results = [];
      for (i = _k = 0, _len2 = objects_mapped.length; _k < _len2; i = ++_k) {
        object = objects_mapped[i];
        _results.push({
          index: i,
          dist: util.distance(subject, object, {
            stdv: stdv,
            weights: weights
          })
        });
      }
      return _results;
    })();
    sortMap = distances.sort(function(a, b) {
      return a.dist - b.dist;
    });
    sortedObjects = (function() {
      var _k, _len2, _results;
      _results = [];
      for (_k = 0, _len2 = sortMap.length; _k < _len2; _k++) {
        i = sortMap[_k];
        _results.push(objects[i.index]);
      }
      return _results;
    })();
    k = (options != null ? options.k : void 0) || 1;
    return sortedObjects.slice(0, k);
  };

}).call(this);
